{{- range .Values.endpoints_api }}
{{- if eq .backend_service "kubernetes" }}
---
apiVersion: apisix.apache.org/v2
kind: ApisixUpstream
metadata:
  name: kubernetes-api-upstream
  namespace: {{ .namespace }}
spec:
  scheme: {{ .scheme }}
  loadbalancer:
    type: roundrobin
  # Use externalNodes since kubernetes.default.svc is not a K8s Service we manage
  externalNodes:
    - type: Domain
      name: kubernetes.default.svc
      port: {{ .service_port }}
      weight: 1
{{- end }}
---
apiVersion: apisix.apache.org/v2
kind: ApisixRoute
metadata:
  name: {{ printf "%s-route" .name }}
  namespace: {{ .namespace }}
  labels:
    app.kubernetes.io/name: {{ $.Chart.Name }}
    app.kubernetes.io/managed-by: {{ $.Release.Service }}
    helm.sh/chart: {{ $.Chart.Name }}-{{ $.Chart.Version }}
    app.kubernetes.io/instance: {{ $.Release.Name }}
spec:
  http:
  - name: {{ printf "%s-route" .name }}
    match:
      paths:
      - {{ .path }}
    {{- if eq .backend_service "kubernetes" }}
    # For K8s API, reference the ApisixUpstream we created
    upstreams:
      - name: kubernetes-api-upstream
    {{- else }}
    backends:
      - serviceName: {{ .backend_service }}
        servicePort: {{ .service_port }}
        resolveGranularity: service
    {{- end }}
    plugins:
    - name: limit-count
      enable: true
      config:
        count: {{ .rate_limit_count }}
        time_window: 60
        key_type: var
        key: http_authorization
        rejected_code: 429
    - name: authz-keycloak
      enable: true
      config:
        resource_registration_endpoint: {{ $.Values.auth.resource_registration_endpoint }}
        token_endpoint: {{ $.Values.auth.token_endpoint }}
        client_id: {{ $.Values.auth.client_id }}
        client_secret: "$ENV://CLIENT_SECRET"
        policy_enforcement_mode: "ENFORCING"
        ssl_verify: false
        permissions:
          {{- range .permissions }}
          - {{ . }}
          {{- end }}
    {{- if eq .backend_service "kubernetes" }}
    # Inject K8s ServiceAccount token for kubernetes.default.svc calls
    # Priority MUST be LOWER than authz-keycloak (2000) to run AFTER auth validation
    - name: serverless-pre-function
      enable: true
      config:
        _meta:
          priority: 1999
        phase: access
        functions:
          - |
            return function(conf, ctx)
              local core = require("apisix.core")
              local token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
              local file, err = io.open(token_file, "r")
              if not file then
                core.log.error("Failed to open SA token: ", err)
                return 500, {message = "Failed to read ServiceAccount token"}
              end
              local token = file:read("*all")
              file:close()
              if not token or token == "" then
                core.log.error("SA token is empty")
                return 500, {message = "ServiceAccount token is empty"}
              end
              token = token:gsub("%s+", "")
              core.request.set_header(ctx, "Authorization", "Bearer " .. token)
              core.request.set_header(ctx, "Cookie", nil)
              core.request.set_header(ctx, "X-Auth-Request-Access-Token", nil)
              core.log.info("Injected K8s SA token for: ", ctx.var.uri)
            end
    {{- end }}
    - name: proxy-rewrite
      enable: true
      config:
        uri: {{ .service_path }}
        scheme: {{ .scheme }}
---
{{- end }}
